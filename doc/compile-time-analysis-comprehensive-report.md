# IronGuard Compile Time Analysis - Comprehensive Report

**Generated**: 2025-11-11

**Purpose**: Comprehensive analysis of TypeScript compilation performance impact when using `OrderedSubsequences` and `AllPrefixes` types at different lock levels

---

## Executive Summary

This report provides a comprehensive analysis of the compilation time performance of IronGuard's type system, specifically focusing on:
- The `OrderedSubsequences<T>` type (generates all ordered subsequences, O(2^N) combinations)
- The `AllPrefixes<T>` type (generates all prefixes, O(N) combinations)
- Performance characteristics at different lock levels (1-20)
- Impact of using these types in function parameters

### Key Findings

1. **Critical Performance Threshold at Lock Level 15**: There is a significant performance cliff when using `OrderedSubsequences` with function parameters at lock level 15, where compilation time jumps from ~1.1s to ~2.2s (2x increase).

2. **Type Definition vs Usage**: The type definition itself compiles quickly (~1s), but using it in function parameters causes the performance degradation.

3. **OrderedSubsequences vs AllPrefixes**: `AllPrefixes` consistently compiles in ~1s regardless of lock level or function usage, making it 2x faster than `OrderedSubsequences` at level 15.

4. **Lock Level 15 is a Turning Point**: After level 15, the performance suddenly improves and remains stable at ~1.4s through level 20.

---

## Detailed Analysis

### Performance by Lock Level

#### Lock Level 15: The Critical Threshold

| Type | Type Definition | With 1 Function | With 5 Functions |
|------|----------------|-----------------|------------------|
| OrderedSubsequences | 1,132ms | 2,185ms (+93%) | 2,165ms (+91%) |
| AllPrefixes | 1,022ms | 1,032ms (+1%) | 1,027ms (+0.5%) |

**Key Observation**: Lock level 15 shows a dramatic 93% increase in compilation time when `OrderedSubsequences` is used in function parameters, while `AllPrefixes` shows almost no increase.

#### Comparison Across Lock Levels

| Lock Level | OrderedSubsequences<br/>(Type + Function) | AllPrefixes<br/>(Type + Function) | Performance Ratio |
|------------|------------------------------------------|----------------------------------|-------------------|
| 10 | 1,038ms + 1,098ms = 2,136ms | 1,026ms + 1,020ms = 2,046ms | 1.04x |
| 13 | 1,075ms + 1,337ms = 2,412ms | 1,021ms + 1,023ms = 2,044ms | 1.18x |
| 14 | 1,102ms + 1,665ms = 2,767ms | 1,026ms + 1,039ms = 2,065ms | 1.34x |
| **15** | **1,132ms + 2,185ms = 3,317ms** | **1,022ms + 1,032ms = 2,054ms** | **1.61x** |
| 16 | 1,228ms + 1,249ms = 2,477ms | 1,033ms + 1,030ms = 2,063ms | 1.20x |
| 17 | 1,432ms + 1,453ms = 2,885ms | 1,032ms + 1,032ms = 2,064ms | 1.40x |
| 20 | 1,447ms + 1,448ms = 2,895ms | 1,023ms + 1,040ms = 2,063ms | 1.40x |

### Why Lock Level 15?

The 2^15 = 32,768 combinations generated by `OrderedSubsequences<readonly [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]>` appears to hit a threshold in TypeScript's type checker where it:
1. Must evaluate all 32,768 possible union members when checking function parameter compatibility
2. Crosses an internal caching or optimization boundary
3. Triggers more expensive type narrowing algorithms

Interestingly, at level 16 (2^16 = 65,536 combinations), TypeScript appears to use a different optimization strategy, resulting in better performance than level 15.

### Impact of Function Count

**Lock Level 15 - OrderedSubsequences**:
- Type definition only: 1,132ms
- With 1 function: 2,185ms (+93%)
- With 3 functions: 2,166ms (+91%)
- With 5 functions: 2,165ms (+91%)

**Key Insight**: Adding more functions doesn't significantly increase compile time beyond the first function. The overhead is in the type instantiation when first used in a function signature, not in repeated usage.

---

## Technical Deep Dive

### OrderedSubsequences Type Complexity

```typescript
type OrderedSubsequences<T extends readonly any[]> =
  T extends readonly [infer First, ...infer Rest]
    ? OrderedSubsequences<Rest> | readonly [First, ...OrderedSubsequences<Rest>]
    : readonly [];
```

**Complexity**: O(2^N) - Generates the complete powerset while maintaining order
- Lock level 10: 1,024 combinations
- Lock level 14: 16,384 combinations
- Lock level 15: 32,768 combinations ⚠️ **Critical threshold**
- Lock level 16: 65,536 combinations (surprisingly better performance)

### AllPrefixes Type Complexity

```typescript
type AllPrefixes<T extends readonly any[]> = 
  T extends readonly [infer First, ...infer Rest]
    ? readonly [] | readonly [First] | readonly [First, ...AllPrefixes<Rest>]
    : readonly [];
```

**Complexity**: O(N) - Only generates sequential prefixes
- Lock level 10: 11 combinations ([], [1], [1,2], ..., [1,2,3,4,5,6,7,8,9,10])
- Lock level 15: 16 combinations
- Lock level 20: 21 combinations

**Performance**: Consistently ~1s regardless of lock level or usage pattern.

---

## Recommendations

### By Use Case

#### ✅ Safe: Lock Levels 1-14
- **OrderedSubsequences**: Acceptable performance (< 2s compile time)
- **AllPrefixes**: Excellent performance (< 1s compile time)
- **Recommendation**: Use either based on whether you need lock skipping

#### ⚠️ Warning: Lock Level 15
- **OrderedSubsequences**: Significant performance impact (2.2s with functions)
- **AllPrefixes**: Still performs well (~1s)
- **Recommendation**: Strongly prefer `AllPrefixes` at this level, or use specific `ValidLockXContext` types

#### ✅ Acceptable: Lock Levels 16-20
- **OrderedSubsequences**: Moderate performance (~1.5s)
- **AllPrefixes**: Excellent performance (~1s)
- **Recommendation**: Prefer `AllPrefixes` for best performance

### General Guidelines

1. **Prefer AllPrefixes when possible**
   ```typescript
   // Good: Linear complexity
   type ValidContexts = AllPrefixes<readonly [1, 2, 3, 4, 5]>;
   async function myFunction(ctx: LockContext<ValidContexts>) { }
   ```

2. **Avoid OrderedSubsequences above level 14**
   ```typescript
   // Problematic at level 15+
   type FlexibleContexts = OrderedSubsequences<readonly [1, 2, ..., 15]>;
   async function slowCompile(ctx: LockContext<FlexibleContexts>) { }
   ```

3. **Use specific ValidLockXContext types when possible**
   ```typescript
   // Best: No union expansion needed
   async function needsLock3<T extends readonly LockLevel[]>(
     ctx: ValidLock3Context<T>
   ) { }
   ```

4. **Consider lock hierarchy grouping**
   ```typescript
   // Instead of one huge hierarchy, split into logical groups
   type DatabaseLocks = AllPrefixes<readonly [1, 2, 3, 4, 5]>;
   type CacheLocks = AllPrefixes<readonly [6, 7, 8, 9, 10]>;
   type NetworkLocks = AllPrefixes<readonly [11, 12, 13, 14, 15]>;
   ```

---

## Performance Budget Recommendations

Based on typical developer expectations for TypeScript compilation:

| Scenario | Max Compile Time | Recommended Approach |
|----------|------------------|----------------------|
| Interactive development (watch mode) | < 1s | AllPrefixes up to level 20 |
| CI/CD builds | < 3s | OrderedSubsequences up to level 14 |
| One-off type checks | < 5s | OrderedSubsequences up to level 15 |

---

## Conclusion

The `OrderedSubsequences` type provides maximum flexibility by allowing lock skipping patterns, but comes with significant compile-time costs starting at lock level 15. For most applications:

1. **Lock levels 1-14**: Both types perform acceptably
2. **Lock level 15**: Critical threshold - avoid `OrderedSubsequences` in function parameters
3. **Lock levels 16-20**: Performance stabilizes but `AllPrefixes` remains significantly faster

**Recommended Maximum for Production Use**:
- **OrderedSubsequences**: Lock level 14 (16,384 combinations, ~1.7s compile)
- **AllPrefixes**: Lock level 20+ (21 combinations, ~1s compile)

For applications requiring more than 14 locks with flexible patterns, consider:
- Refactoring to use multiple smaller lock hierarchies
- Using `AllPrefixes` if lock skipping isn't essential
- Using specific `ValidLockXContext` types in function signatures
- Restructuring the lock architecture to reduce the number of levels needed

---

## Appendix: Raw Data

Complete performance data is available in:
- `compile-time-analysis-results.json` - Raw timing data for all levels
- `detailed-analysis-level15.md` - Deep dive into the critical threshold
- Test files used for analysis are in `.tmp-compile-analysis/` (cleaned up after each run)

### Test Methodology
- TypeScript version: 5.0.0+
- Node.js version: 16.0.0+
- Each measurement averaged over 3-5 iterations
- Measurements taken with `tsc --noEmit --skipLibCheck`
- Warm-up compilation performed before measurements
- All tests run in isolated files to avoid caching effects
